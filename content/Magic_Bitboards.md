---
title: Magic Bitboards
---
**[Home](Home "Home") \* [Board Representation](Board_Representation "Board Representation") \* [Bitboards](Bitboards "Bitboards") \* [Sliding Piece Attacks](Sliding_Piece_Attacks "Sliding Piece Attacks") \* Magic Bitboards**



[ [Paul Klee](Category:Paul_Klee "Category:Paul Klee") - Magic Garden, 1926 <a id="cite-note-1" href="#cite-ref-1">[1]</a>
**Magic Bitboards**,  

a multiply-right-shift [perfect hashing](Hash_Table#PerfectHashing "Hash Table") algorithm to index an attack bitboard database - which leaves both line-attacks of bishop or rook in one run. Thanks to the fast 64-bit [multiplication](General_Setwise_Operations#Multiplication "General Setwise Operations") and fast and huge [caches](https://en.wikipedia.org/wiki/Cache) of recent processors, Magic Bitboards has become a [de facto standard](https://en.wikipedia.org/wiki/De_facto_standard) of modern bitboard engines, as used for instance in [Crafty](Crafty "Crafty"), [Arasan](Arasan "Arasan"), [Stockfish](Stockfish "Stockfish") and [Houdini](Houdini "Houdini"). While [Robert Hyatt](Robert_Hyatt "Robert Hyatt") reported no immediate speed gain over [Rotated Bitboards](Rotated_Bitboards "Rotated Bitboards") in Crafty <a id="cite-note-2" href="#cite-ref-2">[2]</a> , [Jon Dart](Jon_Dart "Jon Dart") mentioned a 20-25% speedup <a id="cite-note-3" href="#cite-ref-3">[3]</a> in Arasan over rotated. 



## How it works


A magic move-bitboard generation technique consists of four key steps:



1. Mask the relevant occupancy bits to form a key. For example if you had a rook on a1, the relevant occupancy bits will be from a2-a7 and b1-g1.
2. Multiply the key by a "magic number" to obtain an index mapping. This magic number can be generated by brute-force [trial and error](Trial_and_Error "Trial and Error") quite easily although it isn't 100% certain that the magic number is the best possible (see step 3).
3. Right shift the index mapping by 64-n bits to create an index, where n is the number of bits in the index. A better magic number will have less bits required in the index.
4. Use the index to reference a preinitialized move database.


The following illustration should give an impression, how magic bitboards work. All masked relevant occupied bits are perfectly hashed to the consecutive occupied state to index the pre-calculated attack-sets. Constructive collisions, where different occupancies map same attack-sets - since different bits are outer redundant bits "behind" the first blocker, are desired and even necessary to apply a perfect hashing with N bits.




```C++
                                        any consecutive
relevant occupancy                      combination of
bishop b1, 5 bits                       the masked bits
. . . . . . . .     . . . . . . . .     . . .[C D E F G]
. . . . . . . .     . 1 . . . . . .     . . . . . . . .
. . . . . . G .     . 1 . . . . . .     . . . . . . . .
. . . . . F . .     . 1 . . . . . .     . . . . . . . .
. . . . E . . .  *  . 1 . . . . . .  =  . . garbage . .    >> (64- 5)
. . . D . . . .     . 1 . . . . . .     . . . . . . . .
. . C . . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .

                                        any consecutive
relevant occupancy                      combination of
bishop d4, 9 bits                       the masked bits
. . . . . . . .     . . . . . . . .     2 4 5 B C E F G]
. . . . . . G .     . . .some . . .     . . . . . . .[1
. 5 . . . F . .     . . . . . . . .     . . . . . . . .
. . 4 . E . . .     . . .magic. . .     . . . . . . . .
. . . . . . . .  *  . . . . . . . .  =  . . garbage . .    >> (64- 9)
. . C . 2 . . .     . . .bits . . .     . . . . . . . .
. B . . . 1 . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .

                                        any consecutive
relevant occupancy                      combination of
rook d4, 10 bits                        the masked bits
. . . . . . . .     . . . . . . . .     4 5 6 B C E F G]
. . . 6 . . . .     . . .some . . .     . . . . . .[1 2
. . . 5 . . . .     . . . . . . . .     . . . . . . . .
. . . 4 . . . .     . . .magic. . .     . . . . . . . .
. B C . E F G .  *  . . . . . . . .  =  . . garbage . .    >> (64-10)
. . . 2 . . . .     . . .bits . . .     . . . . . . . .
. . . 1 . . . .     . . . . . . . .     . . . . . . . .
. . . . . . . .     . . . . . . . .     . . . . . . . .

                                        any consecutive
relevant occupancy                      combination of
rook a1, 12 bits                        the masked bits
. . . . . . . .     . . . . . . . .     5 6 B C D E F G]
6 . . . . . . .     . . .some . . .     . . . .[1 2 3 4
5 . . . . . . .     . . . . . . . .     . . . . . . . .
4 . . . . . . .     . . .magic. . .     . . . . . . . .
3 . . . . . . .  *  . . . . . . . .  =  . . garbage . .    >> (64-12)
2 . . . . . . .     . . .bits . . .     . . . . . . . .
1 . . . . . . .     . . . . . . . .     . . . . . . . .
. B C D E F G .     . . . . . . . .     . . . . . . . .

```

The above illustration is correct for the b1 bishop, since it has only one ray and one bit per file and works [kindergarten](Kindergarten_Bitboards "Kindergarten Bitboards") like. In general a one to one mapping of N scattered occupied bits to N consecutive bits is not always possible due to overflows. A perfect mapping of N scattered bits to N consecutive bits is likely not minimal for most squares. It requires one or two gaps inside the consecutive N bits, to avoid collisions, blowing up the table size.


But the purpose is to perfectly hash attack-sets rather than consecutive occupied bits. The number of distinct attack-sets is much smaller than the relevant occupancies. Thus, with the help of constructive collisions, some initial guess how to map the bits, and/or [trial and error](Trial_and_Error "Trial and Error"), using exactly N bits is always possible. If one tries hard enough to maximize constructive collisions - even less. There are some N-1 ones reported at [Best Magics so far](Best_Magics_so_far "Best Magics so far"), which will half the individual table size for some squares in the widespread [Fancy Magic Bitboards](#Fancy) approach.



## Perfect Hashing


Magic bitboards applies [perfect hashing](Hash_Table#PerfectHashing "Hash Table"). A [surjective function](https://en.wikipedia.org/wiki/Surjection), to map the vector of all relevant occupancies to a range of attack-sets per square. The less bits the attack-set - the closer the blockers, the more those attack-sets are shared by occupancies with different, but redundant outer squares.



* The **cardinality** of all **relevant occupancies** is determined by the number of bits to map, varying from five to twelve - thus, the cardinality is the power of two the number of bits, varying from 32 to 4096.
* The **cardinality** of **distinct attack-sets** is determined by the product of the length of each of the max four direction rays greater than zero (or one). The rook on d4 has 3\*4\*3\*4 = 144 distinct attack-sets, a bishop on a8 has only 7.


The **ratio** of both cardinalities, that is all **relevant occupancies** versus the all **distinct attack-sets** is illustrated below: As a quarter of a board - due to the symmetry, the other squares may deduced by flipping and mirroring. Noticeable is the huge 4096/49 ratio of 2^12 occupied states versus 7 times 7 attack-sets of the edge rooks - 12 bits instead of 6. Those "expensive" squares make constructive collisions very desirable. To become more "minimal" by saving an index bit - to halve down the table for one square or the other.





|  bishop on square
 |  #occs/#attset
 |  rook on square
 |
| --- | --- | --- |
|  |  A
 |  B
 |  C
 |  D
 |  |  A
 |  B
 |  C
 |  D
 |
|  8
 |  64/7
 |  32/6
 |  32/10
 |  32/12
 |  |  8
 |  4096/49
 |  2048/42
 |  2048/70
 |  2048/84
 |
|  7
 |  32/6
 |  32/6
 |  32/10
 |  32/ 12
 |  7
 |  2048/42
 |  1024/36
 |  1024/ 60
 |  1024/ 72
 |
|  6
 |  32/10
 |  32/10
 |  128/40
 |  128/ 48
 |  6
 |  2048/70
 |  1024/60
 |  1024/100
 |  1024/120
 |
|  5
 |  32/12
 |  32/12
 |  128/48
 |  512/108
 |  5
 |  2048/84
 |  1024/72
 |  1024/120
 |  1024/144
 |
|  |
|  bishop on square
 |  rook on square
 |
|  |  A
 |  B
 |  C
 |  D
 |  |  A
 |  B
 |  C
 |  D
 |
|  8
 |  9.14
 |  5.33
 |  3.20
 |  2.67
 |  8
 |  83.59
 |  48.76
 |  29.26
 |  24.38
 |
|  7
 |  5.33
 |  5.33
 |  3.20
 |  2.67
 |  7
 |  48.76
 |  28.44
 |  17.07
 |  14.22
 |
|  6
 |  3.20
 |  3.20
 |  3.20
 |  2.67
 |  6
 |  29.26
 |  17.07
 |  10.24
 |  8.53
 |
|  5
 |  2.67
 |  2.67
 |  2.67
 |  4.74
 |  5
 |  24.38
 |  14.22
 |  8.53
 |  7.11
 |


The idea to implement minimal perfect hashing by an additional 16-bit indirection turned out to be slower (see conditional compiles in Pradu Kannan's source <a id="cite-note-9" href="#cite-ref-9">[9]</a> ).


Recent table sizes were about 38 KiB for the bishop attacks, but still about 800 KiB for rook attacks (Fancy). That sounds huge, considering L1 and L2 (L3) cache-sizes and number of cachelines and pages needed - we likely fetch distinct cachelines for each different square or occupancy. On the other hand caches and pages become larger in future processors. And occupancy and squares of the lookups don't change that randomly inside a search that we can still expect a lot of L1-hits. Unfortunately changes in occupancy outside the blockers and therefor not affecting the attack-set will introduce some more cache misses.



### Wishing Dreams


Since there are 1428/4900 **distinct** attack sets for the bishop/rook attacks, we can use 11(2048 > 1428)/13(8196 > 4900) index bits for all bishop/rook attack bitboards. The table size will be 16KB for the bishop attacks and 64KB for rook attacks. To make it possible, we must find a group of magics (one per square and dependent each other). All the magics in the group must hash its all **relevant occupancies** into the same 11/13 bit index without any collision with others (anyhow for each square, different occupancies can hash to the same attack sets).




```C++
U64 bishopAttacks[2048]; // 16KB
U64 rookAttacks[8196]; // 64KB

struct GMagic {
   U64 mask;  // to mask relevant squares of both lines (no outer squares) and include sliding piece itself
   U64 magic; // magic 64-bit factor
};

GMagic mBishopTbl[64]; //1KB
GMagic mRookTbl[64]; //1KB

U64 bishopAttacks(U64 occ, enumSquare sq) {
   occ &= mBishopTbl[sq].mask;
   occ *= mBishopTbl[sq].magic;
   occ >>= 64-11;  //fixed shift
   return bishopAttacks[occ]; //no offset
}

U64 rookAttacks(U64 occ, enumSquare sq) {
   occ &= mRookTbl[sq].mask;
   occ *= mRookTbl[sq].magic;
   occ >>= 64-13;
   return rookAttacks[occ];
}


```

But the idea seems like a wishing dream. Can we find ONE of the **magic group** of magics? Does it exist in theory? If not, can we use more bits to reach the condition? If yes, can we find a good magic group? A good magic group means that all the hash value <=n, so we can reduce the table size to n, until it reach to 1428/4900. Enough? If all hash values are grouped by square, can we think about using the [Sharing Attacks](#PostMask) method?



## Implementations


Despite its huge table size, register usage and code size are important issues as well - and here Magic Bitboards are unbeatable. There are enough variations of [space-time tradeoff](Space-Time_Tradeoff "Space-Time Tradeoff") and implementation details of that theme for all who like to play the optimization game. [C](C "C")-source code with various precompiler options is available from [Pradu Kannan's](Pradu_Kannan "Pradu Kannan") site. MINIMIZE\_MAGIC is about Plain versus Fancy <a id="cite-note-10" href="#cite-ref-10">[10]</a> , while PERFECT\_MAGIC\_HASH enables an additional indirection via 16-bit indices. As always, with space-time tradeoffs - it depends on the individual cache- and [memory footprint](https://en.wikipedia.org/wiki/Memory_footprint) inside a particular chess program and the hardware architecture, which solution is preferable.




### Fancy


Fancy Magic Bitboards is the main stream implementation as proposed by [Pradu Kannan](Pradu_Kannan "Pradu Kannan") with individual table sizes for each square. It requires an individual shift, to leave that many index bits remaining as determined by the population of relevant occupancies. As mentioned, if one tries hard enough to maximize constructive collisions while [looking for magics](Looking_for_Magics "Looking for Magics"), one may half the size for several individual squares, see [Best Magics so far](Best_Magics_so_far "Best Magics so far").




```C++
U64 attack_table[...]; // ~840 KiB all rook and bishop attacks, less with constructive collisions optimization

struct SMagic {
   U64* ptr;  // pointer to attack_table for each particular square
   U64 mask;  // to mask relevant squares of both lines (no outer squares)
   U64 magic; // magic 64-bit factor
   int shift; // shift right
};

SMagic mBishopTbl[64];
SMagic mRookTbl[64];

U64 bishopAttacks(U64 occ, enumSquare sq) {
   U64* aptr = mBishopTbl[sq].ptr;
   occ      &= mBishopTbl[sq].mask;
   occ      *= mBishopTbl[sq].magic;
   occ     >>= mBishopTbl[sq].shift;
   return aptr[occ];
}

U64 rookAttacks(U64 occ, enumSquare sq) {
   U64* aptr = mRookTbl[sq].ptr;
   occ      &= mRookTbl[sq].mask;
   occ      *= mRookTbl[sq].magic;
   occ     >>= mRookTbl[sq].shift;
   return aptr[occ];
}

```





### Plain


Plain Magic Bitboards, [Lasse Hansen's](Lasse_Hansen "Lasse Hansen") initial approach, takes much more memory for homogeneous two-dimensional attack [arrays](Array "Array"). 32 KiB per rook square, 4 KiB for each bishop square. It does not need a variable shift and therefor needs one processor register less to further reduce register pressure, despite shorter code. Unfortunately, so far, there are two [rook corner squares](Best_Magics_so_far "Best Magics so far") (0 and 7), which prohibit dividing the rook table size by two.




```C++
U64 mBishopAttacks[64] [512]; // 256 K
U64 mRookAttacks  [64][4096]; // 2048K

struct SMagic {
   U64 mask;  // to mask relevant squares of both lines (no outer squares)
   U64 magic; // magic 64-bit factor
};

SMagic mBishopTbl[64];
SMagic mRookTbl  [64];

U64 bishopAttacks(U64 occ, enumSquare sq) {
   occ &= mBishopTbl[sq].mask;
   occ *= mBishopTbl[sq].magic;
   occ >>= 64-9;
   return mBishopAttacks[sq][occ];
}

```





### Fixed shift Fancy


A fancy fixed shift variation was introduced by [Onno Garms](Onno_Garms "Onno Garms"), looking for magics producing factors with appropriate reduced value ranges. That is, leave 12 bit rook indices for all squares, but with upper bit(s) clear for all possible occupancies for all the squares with less than 12 relevant bits, so that it efficiently becomes a less 12 bit index. Onno believes that it is possible to find magic factors with that property for most of those squares, to come close to the fancy table size with the advantage of a fixed shift <a id="cite-note-11" href="#cite-ref-11">[11]</a> . Even an "overlapping" of square arrays is feasible, if they contain accordant unused slot gaps on both ends. [Volker Annuss](Volker_Annuss "Volker Annuss") came up with a fixed shift solution of only 800 KiB and below <a id="cite-note-12" href="#cite-ref-12">[12]</a> <a id="cite-note-13" href="#cite-ref-13">[13]</a>, and more recently even innovated with [Black Magic Bitboards](#BlackMagics). 




```C++
U64 attack_table[...]; // > 800 KiB  - 1.x MiB  - depending on the effort on looking for magics

struct SMagic {
   U64* ptr;  // pointer to attack_table for each particular square
   U64 mask;  // to mask relevant squares of both lines (no outer squares)
   U64 magic; // magic 64-bit factor
};

SMagic mBishopTbl[64];
SMagic mRookTbl[64];

U64 rookAttacks(U64 occ, enumSquare sq) {
   U64* aptr = mRookTbl[sq].ptr;
   occ      &= mRookTbl[sq].mask;
   occ      *= mRookTbl[sq].magic;
   occ     >>= 64-12;
   return aptr[occ];
}

```





### Black Magic Bitboards


[Volker Annuss'](Volker_Annuss "Volker Annuss") most recent innovation and further improvement of his already dense 700 KiB [fixed shift fancy](#FixedShiftFancy) reference implementation is called **Black Magic Bitboards**, introduced in [CCC](CCC "CCC") in August 2017 <a id="cite-note-14" href="#cite-ref-14">[14]</a>. Instead of [intersection](General_Setwise_Operations#Intersection "General Setwise Operations") with a mask to clear the not relevant occupancy bits, he used the [union](General_Setwise_Operations#Union "General Setwise Operations") with the [complement](General_Setwise_Operations#ComplementSet "General Setwise Operations") of mask to set all not relevant occupancy bits. 




```C++
  and mask[d4]  vs.   or ~mask[d4]
. . . . . . . .     1 1 1 1 1 1 1 1
. . . 1 . . . .     1 1 1 . 1 1 1 1
. . . 1 . . . .     1 1 1 . 1 1 1 1
. . . 1 . . . .     1 1 1 . 1 1 1 1
. 1 1 . 1 1 1 .     1 . . 1 . . . 1
. . . 1 . . . .     1 1 1 . 1 1 1 1
. . . 1 . . . .     1 1 1 . 1 1 1 1
. . . . . . . .     1 1 1 1 1 1 1 1

```

This trick, which basically adds a huge constant to the occupancy factor, enables to find **Black Magics** yielding in even smaller array sizes per square, determined by maximum and minimum index - the latter no longer zero for the empty occupancy! Unfortunately so far, the individual savings with denser square arrays don't completely advance to the size of the combined overlapping table, since overlapping became harder due to smaller gaps <a id="cite-note-15" href="#cite-ref-15">[15]</a> . However, 692 KiB for the complete rook and bishop attack table is the new fixed shift reference. Black Magic Bitboards are now used in Volker's engine [Arminius](Arminius "Arminius") <a id="cite-note-16" href="#cite-ref-16">[16]</a> <a id="cite-note-17" href="#cite-ref-17">[17]</a>:




```C++
U64 attack_table[88507]; // 692 KiB for published black magics by Volker Annuss (new size 88316 aka 690 KiB) 

struct SBlackMagic {
   U64* ptr;  // pointer to attack_table for each particular square
   U64 notmask;  // to mask relevant squares of both lines (no outer squares)
   U64 blackmagic; // black magic 64-bit factor
};

SBlackMagic mBishopTbl[64];
SBlackMagic mRookTbl[64];

U64 rookAttacks(U64 occ, enumSquare sq) {
   U64* aptr = mRookTbl[sq].ptr;
   occ      |= mRookTbl[sq].notmask;
   occ      *= mRookTbl[sq].blackmagic;
   occ     >>= 64-12;
   return aptr[occ];
}

```





### Byte Lookup


Since there are only up to 144 different attack sets per square, [Robert Houdart](Robert_Houdart "Robert Houdart") proposed to lookup [bytes](Byte "Byte") by square and hashed occupancy for a minimal perfect hashing with an additional indirection via an offset per square, which is successfully used in his engine [Houdini](Houdini "Houdini") <a id="cite-note-18" href="#cite-ref-18">[18]</a> . Following sample code uses the Plain fixed shift method, while it may also applied for the dense Fancy one.




```C++
byte mBishopAttacks[64] [512]; // 32 K
byte mRookAttacks  [64][4096]; // 256 K

U64 mRookLookup[4900];  // 39 K
U64 mBishopLookup[1428];  // 11 K

struct SMagic {
   U64 mask;  // to mask relevant squares of both lines (no outer squares)
   U64 magic; // magic 64-bit factor
   int offset;   // offset into lookup table
};

SMagic mBishopTbl[64];
SMagic mRookTbl  [64];

U64 bishopAttacks(U64 occ, enumSquare sq) {
   occ &= mBishopTbl[sq].mask;
   occ *= mBishopTbl[sq].magic;
   occ >>= 64-9;
   return mBishopLookup[mBishopTbl[sq].offset + mBishopAttack[sq][occ]];
}

```





### 32-bit Magics


Optimizations are possible for 32-bit systems, as proposed by [Grant Osborne](Grant_Osborne "Grant Osborne") <a id="cite-note-19" href="#cite-ref-19">[19]</a> . Instead of letting the compiler split up a 64-bit multiply, two 32-bit multiplications can be manually implemented. Multiply the low bits of the magic with the low bits of the key and add it with the product of the high bits of the magic and the high bits of the key and use the upper bits of the sum to index the move database. For the bishops one may try only one 32-bit multiplication after xoring the masked high and low half.




```C++
struct {
  unsigned int rookMaskLo;
  unsigned int rookMaskHi;
  unsigned int rookMagicLo;
  unsigned int rookMagicHi;
  unsigned int rookShift;
  U64 *pRookAttacks;
} sm[64];

U64 rookAttacks(U64 occ, enumSquare sq) {
   unsigned int lo = (int) occ;
   unsigned int hi = (int)(occ >> 32);
   lo &= sm[sq].rookMaskLo;
   hi &= sm[sq].rookMaskHi;
   lo *= sm[sq].rookMagicLo;
   hi *= sm[sq].rookMagicHi;
   lo  = (lo ^ hi) >> sm[sq].rookShift;
   return sm[sq].pRookAttacks[lo];
}

```





### Sharing Attacks


The development has not finished. [Lasse Hansen](Lasse_Hansen "Lasse Hansen") came up with another stunning idea <a id="cite-note-20" href="#cite-ref-20">[20]</a> , to use a final [intersection](General_Setwise_Operations#Intersection "General Setwise Operations") by [attacks on an empty board](On_an_empty_Board "On an empty Board"), to share tables by two (rooks) or even four (bishops) squares. Bishop sharing is simple to understand, since there are light and dark colored bishops with disjoint attacks-sets, able to share the pre-calculated union of two square-attacks.


The trick is to share even equal colored bishops and rooks where both attack-sets are not disjoint - but all members of the intersection are always set, since they are direct neighbors of both sliders. This is how rooks and bishops may share union-attack-sets by two resp. four squares:




```C++
int rookSharing[64] = {
   0,  1,  2,  3,  4,  5,  6,  7,
   1,  0,  3,  2,  5,  4,  7,  6,
   8,  9, 10, 11, 12, 13, 14, 15,
   9,  8, 11, 10, 13, 12, 15, 14,
  16, 17, 18, 19, 20, 21, 22, 23,
  17, 16, 19, 18, 21, 20, 23, 22,
  24, 25, 26, 27, 28, 29, 30, 31,
  25, 24, 27, 26, 29, 28, 31, 30,
};

int bishopSharing[64] = {
   0,  2,  4,  4,  4,  4, 12, 14,
   0,  2,  5,  5,  5,  5, 12, 14,
   0,  2,  6,  6,  6,  6, 12, 14,
   0,  2,  7,  7,  7,  7, 12, 14,
   1,  3,  8,  8,  8,  8, 13, 15,
   1,  3,  9,  9,  9,  9, 13, 15,
   1,  3, 10, 10, 10, 10, 13, 15,
   1,  3, 11, 11, 11, 11, 13, 15,
};

```

On the cost of one additional and-instruction, post-masking has the potential to almost halve the rook tables - and even better for the already small bishop tables. Additionally, four union attack bitboards can be shared by eight rook- and six bishop-squares.




```C++
R 1 1 1 1 1 1 1    1 R 1 1 1 1 1 1    1 1 R 1 1 1 1 1    1 1 1 R 1 1 1 1
B R 1 1 1 1 1 1    R B 1 1 1 1 1 1    1 1 B R 1 1 1 1    1 1 R B 1 1 1 1
1 1 1 . . . . .    1 1 1 . . . . .    . 1 1 1 1 . . .    . . 1 1 1 . . .
1 1 1 1 . . . 1    1 1 . 1 . . . .    1 . 1 1 1 1 . .    . 1 1 1 . 1 . .
1 1 . 1 1 . 1 .    1 1 . . 1 . . .    . . 1 1 . 1 1 .    1 . 1 1 . . 1 .
1 1 . . 1 B . .    1 1 . . . 1 . .    . . 1 1 . . 1 B    . . 1 1 . . . 1
1 1 . . 1 1 1 .    1 1 . . . . 1 .    . . 1 1 . . 1 1    . . 1 1 . . . .
1 1 . 1 . . 1 1    1 1 . . . . . 1    . . 1 1 . 1 . .    . . 1 1 . . . .

```

If the additional post-mask becomes member of a structure, it exceeds 32 byte in 64-bit mode. A structure of arrays may be preferable than an array of structures.




```C++
U64 attack_table[...]; // ~400K Byte for all rook and (shared) bishop attacks

struct SMagic {
   U64* ptr;      // pointer to attack_table for each particular square
   U64 magic;     // magic 64-bit factor
   U64 premask;   // to mask relevant squares of both lines (no outer squares)
   U64 postmask;  // attacks on the otherwise empty board
   int shift;     // shift right
};

SMagic mBishopTbl[64];
SMagic mRookTbl[64];

U64 bishopAttacks(U64 occ, enumSquare sq) {
   U64* aptr = mBishopTbl[sq].ptr;
   occ      &= mBishopTbl[sq].premask;
   occ      *= mBishopTbl[sq].magic;
   occ     >>= mBishopTbl[sq].shift;
   return      mBishopTbl[sq].postmask & aptr[occ];
}

U64 rookAttacks(U64 occ, enumSquare sq) {
   U64* aptr = mRookTbl[sq].ptr;
   occ      &= mRookTbl[sq].premask;
   occ      *= mRookTbl[sq].magic;
   occ     >>= mRookTbl[sq].shift;
   return      mRookTbl[sq].postmask & aptr[occ];
}

```





### Incorporating the Shift


Another possible improvement was introduced by [Grant Osborne](Grant_Osborne "Grant Osborne") <a id="cite-note-21" href="#cite-ref-21">[21]</a> - to don't store the variable right shift inside an own array or structure element, but to use the almost redundant upper six bit of the magic factor instead - incorporating the shift into the magic number. While using a structure for pre-, postmask, magic and pointer, it's size is 4\*8 = 32-byte or - if properly aligned - the half of one cache line. The additional effort for the right shift 58 to extract the variable shift is likely hidden by the latency of the independent multiplication, improving ipc.




```C++
U64 attack_table[...]; // ~400K Byte for all rook and (shared) bishop attacks

struct SMagic {
   U64* ptr;      // pointer to attack_table for each particular square
   U64 magic;     // magic 64-bit factor, including upper six bits as shift amount
   U64 premask;   // to mask relevant squares of both lines (no outer squares)
   U64 postmask;  // attacks on the otherwise empty board
}; // 32 Byte with 64-bit pointer!

SMagic mBishopTbl[64];
SMagic mRookTbl[64];

U64 bishopAttacks(U64 occ, enumSquare sq) {
   U64* aptr = mBishopTbl[sq].ptr;
   int shift = mBishopTbl[sq].magic >> 58;
   occ      &= mBishopTbl[sq].premask;
   occ      *= mBishopTbl[sq].magic;
   return      mBishopTbl[sq].postmask & aptr[occ >> shift];
}

U64 rookAttacks(U64 occ, enumSquare sq) {
   U64* aptr = mRookTbl[sq].ptr;
   int shift = mRookTbl[sq].magic >> 58;
   occ      &= mRookTbl[sq].premask;
   occ      *= mRookTbl[sq].magic;
   return      mRookTbl[sq].postmask & aptr[occ >> shift];
}

```





### Incorporating Offset


A similar idea as in [Incorporating the Shift](#IncorporatingtheShift) in the domain [fixed shift magics](#FixedShiftFancy) was proposed by [Eugene Kotlov](index.php?title=Eugene_Kotlov&action=edit&redlink=1 "Eugene Kotlov (page does not exist)") concerning the indirection to the stored attack array, using the 16 lower bits of the magic factor as offset <a id="cite-note-22" href="#cite-ref-22">[22]</a>, later even combined with incorporating the shift in the domain of Fancy <a id="cite-note-23" href="#cite-ref-23">[23]</a>.



### Initalization


### Looking for Magics


The main issue is to find 64 magic factors for each rook and bishop square, to ensure they are free of collisions.



* [Looking for Magics](Looking_for_Magics "Looking for Magics")


### Magic Records


You may try to find your own magics - to possibly contribute to the record table for most dense fancy or plain tables. So far, there were no magics found for the expensive rook squares a1 and h1 (0, 7) with less than 12 bits, which would allow to half the plain table size. Is there any prove they don't exist - even with [Black Magic](#BlackMagics)?



* [Best Magics so far](Best_Magics_so_far "Best Magics so far")


## See also


* [BMI2 - PEXT Bitboards](BMI2#PEXTBitboards "BMI2")
* [Kindergarten Bitboards](Kindergarten_Bitboards "Kindergarten Bitboards")


## Publications


* [Pradu Kannan](Pradu_Kannan "Pradu Kannan") (**2007**). *Magic Move-Bitboard Generation in Computer Chess*, as [pdf](http://www.pradu.us/old/Nov27_2008/Buzz/research/magic/Bitboards.pdf)
* [Fritz Reul](Fritz_Reul "Fritz Reul") (**2009**). *New Architectures in Computer Chess*, Ph.D. Thesis, Chapter 3, Magic Hash Functions for Bitboards, [pdf](https://pure.uvt.nl/ws/files/1098572/Proefschrift_Fritz_Reul_170609.pdf)
* [Maurizio Monge](Maurizio_Monge "Maurizio Monge") (**2010**). *On perfect hashing of numbers with sparse digit representation via multiplication by a constant*. [arXiv:1003.3196](https://arxiv.org/abs/1003.3196)
* [Niklas Fiekas](Niklas_Fiekas "Niklas Fiekas") (**2020**). *[The Hashtable Packing Problem](https://backscattering.de/chess/hashtable-packing/)*. (Draft)


## Forum Posts


### 2006


* [Fast(er) bitboard move generator](http://www.open-aurec.com/wbforum/viewtopic.php?t=5015) by [Lasse Hansen](Lasse_Hansen "Lasse Hansen"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), June 14, [2006](Timeline#2006 "Timeline")
* [List of magics for bitboard move generation](http://www.open-aurec.com/wbforum/viewtopic.php?t=5441) by [Pradu Kannan](Pradu_Kannan "Pradu Kannan"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), August 23, 2006
* [Fastest Magic Move Bitboard Generator ready to use](http://www.open-aurec.com/wbforum/viewtopic.php?f=4&t=5452) by [Pradu Kannan](Pradu_Kannan "Pradu Kannan"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), August 25, 2006
* [A Faster Magic Move Bitboard Generator?](http://www.open-aurec.com/wbforum/viewtopic.php?t=5997) by [Grant Osborne](Grant_Osborne "Grant Osborne"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), December 15, 2006


### 2007


* [SEE with magic bitboards](http://www.open-aurec.com/wbforum/viewtopic.php?t=6104) by [Pradu Kannan](Pradu_Kannan "Pradu Kannan"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), January 24, 2007 » [Static Exchange Evaluation](Static_Exchange_Evaluation "Static Exchange Evaluation")
* [Magic bitboards, Java](http://www.talkchess.com/forum/viewtopic.php?t=15896) by Sargon, [CCC](CCC "CCC"), August 19, 2007 » [Java](Java "Java")
* [BitBoard Tests Magic v Non-Rotated 32 Bits v 64 Bits](http://www.talkchess.com/forum/viewtopic.php?t=16002) by [Brian Richardson](Brian_Richardson "Brian Richardson"), [CCC](CCC "CCC"), August 24, 2007 <a id="cite-note-24" href="#cite-ref-24">[24]</a>
* [Magic and precomputation](http://www.open-aurec.com/wbforum/viewtopic.php?f=4&t=6823) by [Onno Garms](Onno_Garms "Onno Garms"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), September 23, 2007


### 2008


* [Magic Move Generation](http://www.talkchess.com/forum/viewtopic.php?topic_view=threads&p=175544&t=19699) by Colin, [CCC](CCC "CCC"), February 18, 2008
* [How to reduce the "bits" used in a magic number](http://www.talkchess.com/forum/viewtopic.php?t=21329) by Charlie Brune, [CCC](CCC "CCC"), May 24, 2008
* [magic move - bitboard orientation](http://www.talkchess.com/forum/viewtopic.php?t=21543) by [Frank Phillips](Frank_Phillips "Frank Phillips"), [CCC](CCC "CCC"), June 01, 2008
* [Incorporating the shift into the magic number](http://www.talkchess.com/forum/viewtopic.php?topic_view=threads&p=196157&t=21329) by [Grant Osborne](Grant_Osborne "Grant Osborne"), [CCC](CCC "CCC"), June 18, 2008


### 2009


* [Magics revisited](http://www.talkchess.com/forum/viewtopic.php?t=25810) by [Richard Pijl](Richard_Pijl "Richard Pijl"), [CCC](CCC "CCC"), January 04, 2009
* [Java & Magic Bitboards](http://www.open-aurec.com/wbforum/viewtopic.php?f=4&t=49948) by [Laurens Winkelhagen](Laurens_Winkelhagen "Laurens Winkelhagen"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), February 03, 2009 » [Java](Java "Java")
* [Magic with fixed shift](http://www.open-aurec.com/wbforum/viewtopic.php?f=4&t=50043) by [Onno Garms](Onno_Garms "Onno Garms"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), March 18, 2009
* [Paradigm shifts](http://www.talkchess.com/forum/viewtopic.php?t=30612) by [Gian-Carlo Pascutto](Gian-Carlo_Pascutto "Gian-Carlo Pascutto"), [CCC](CCC "CCC"), November 14, 2009
* [32-bit Magic experiments](http://www.open-aurec.com/wbforum/viewtopic.php?f=4&t=50616&p=192200) by [Andrew Fan](Andrew_Fan "Andrew Fan"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), December 03, 2009 » [Kindergarten Bitboards](Kindergarten_Bitboards "Kindergarten Bitboards")


### 2010 ...


* [Plain and fancy magic on modern hardware](http://www.talkchess.com/forum/viewtopic.php?t=35858) by [Robert Purves](index.php?title=Robert_Purves&action=edit&redlink=1 "Robert Purves (page does not exist)"), [CCC](CCC "CCC"), August 22, 2010
* [Fixed shift magics with 800KB lookup table](http://www.open-aurec.com/wbforum/viewtopic.php?f=4&t=51162) by [Volker Annuss](Volker_Annuss "Volker Annuss"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), September, 05, 2010
* [Build magics on the fly](http://www.talkchess.com/forum/viewtopic.php?t=39298) by [Marco Costalba](Marco_Costalba "Marco Costalba"), [CCC](CCC "CCC"), June 07, 2011
* [Magic Multiplier Fundamentals](http://www.talkchess.com/forum/viewtopic.php?t=46745) by [Cheney Nattress](index.php?title=Cheney_Nattress&action=edit&redlink=1 "Cheney Nattress (page does not exist)"), [CCC](CCC "CCC"), January 03, 2013
* [Occupancy Variations](http://www.open-chess.org/viewtopic.php?f=5&t=2240) by [CDaley11](Christian_Daley "Christian Daley"), [OpenChess Forum](Computer_Chess_Forums "Computer Chess Forums"), January 25, 2013
* [Magic bitboards: Cache issues and state of the art?](http://www.talkchess.com/forum/viewtopic.php?t=47576) by Samuel Siltanen, [CCC](CCC "CCC"), March 22, 2013
* [Understanding Magic Bitboards](http://www.open-aurec.com/wbforum/viewtopic.php?f=4&t=52783) by [Jaco van Niekerk](index.php?title=Jaco_van_Niekerk&action=edit&redlink=1 "Jaco van Niekerk (page does not exist)"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), April 03, 2013


### 2015 ...


* [question about magic keys generation time](http://www.talkchess.com/forum/viewtopic.php?t=55712) by [Fermin Serrano](Fermin_Serrano "Fermin Serrano"), [CCC](CCC "CCC"), March 19, 2015 » [Looking for Magics](Looking_for_Magics "Looking for Magics")
* [Fancy magic bitboards question](http://www.talkchess.com/forum/viewtopic.php?t=57722) by Eric VanderHelm, [CCC](CCC "CCC"), September 22, 2015


**2016**



* [M42 - A C++ library for Bitboard attack mask generation](http://www.talkchess.com/forum/viewtopic.php?t=60007) by [Syed Fahad](Syed_Fahad "Syed Fahad"), [CCC](CCC "CCC"), April 30, 2016 <a id="cite-note-25" href="#cite-ref-25">[25]</a>
* [understanding fixed shift fancy magic bitboard generation](http://www.talkchess.com/forum/viewtopic.php?t=60065) by [Kalyankumar Ramaseshan](index.php?title=Kalyankumar_Ramaseshan&action=edit&redlink=1 "Kalyankumar Ramaseshan (page does not exist)"), [CCC](CCC "CCC"), May 05, 2016


 [Re: understanding fixed shift fancy magic bitboard generation](http://www.talkchess.com/forum/viewtopic.php?t=60065&start=14) by [Volker Annuss](Volker_Annuss "Volker Annuss"), [CCC](CCC "CCC"), May 06, 2016
* [Why should magic bitboards be sparse?](http://www.talkchess.com/forum/viewtopic.php?t=62561) by Alessandro Power, [CCC](CCC "CCC"), December 21, 2016


**2017**



* [Looking for dense magics](http://www.talkchess.com/forum/viewtopic.php?t=64578) by Lucas Braesch, [CCC](CCC "CCC"), July 11, 2017
* [Black magic bitboards](http://www.talkchess.com/forum/viewtopic.php?t=64790) by [Volker Annuss](Volker_Annuss "Volker Annuss"), [CCC](CCC "CCC"), August 03, 2017 » [Black Magic Bitboards](#BlackMagics)
* [Disproving the existence of some magics](http://www.talkchess.com/forum/viewtopic.php?t=65187) by [Niklas Fiekas](Niklas_Fiekas "Niklas Fiekas"), [CCC](CCC "CCC"), September 16, 2017 » [Looking for Magics](Looking_for_Magics "Looking for Magics")
* [Magic BitBoards Magic numbers](http://www.talkchess.com/forum3/viewtopic.php?f=7&t=65448) by [Tamás Kuzmics](Tam%C3%A1s_Kuzmics "Tamás Kuzmics"), [CCC](CCC "CCC"), October 14, 2017


**2018**



* [magic number comprising offset](http://www.talkchess.com/forum/viewtopic.php?t=66538) by [Eugene Kotlov](index.php?title=Eugene_Kotlov&action=edit&redlink=1 "Eugene Kotlov (page does not exist)"), [CCC](CCC "CCC"), February 07, 2018
* [No bishop magics with fixed shift 8](http://www.talkchess.com/forum/viewtopic.php?t=67051) by [Niklas Fiekas](Niklas_Fiekas "Niklas Fiekas"), [CCC](CCC "CCC"), April 09, 2018 » [Looking for Magics](Looking_for_Magics "Looking for Magics")


**2019**



* [Shift and Address included into Magic number](http://www.talkchess.com/forum3/viewtopic.php?f=7&t=69947) by [Eugene Kotlov](index.php?title=Eugene_Kotlov&action=edit&redlink=1 "Eugene Kotlov (page does not exist)"), [CCC](CCC "CCC"), February 18, 2019
* [On the establishment of domains wherein magic numbers can and cannot exist](http://www.talkchess.com/forum3/viewtopic.php?f=7&t=70341) by [Bruce Newman](index.php?title=Bruce_Newman&action=edit&redlink=1 "Bruce Newman (page does not exist)"), [CCC](CCC "CCC"), March 28, 2019


### 2020 ...


* [Hashtable packing (e.g. to optimize magic bitboards) is strongly NP-complete](http://www.talkchess.com/forum3/viewtopic.php?f=7&t=73071) by [Niklas Fiekas](Niklas_Fiekas "Niklas Fiekas"), [CCC](CCC "CCC"), February 13, 2020 <a id="cite-note-26" href="#cite-ref-26">[26]</a>
* [Looking for Magics, with ternary field types](http://www.talkchess.com/forum3/viewtopic.php?f=7&t=73593) by [Fabian von der Warth](index.php?title=Fabian_von_der_Warth&action=edit&redlink=1 "Fabian von der Warth (page does not exist)"), [CCC](CCC "CCC"), April 07, 2020 » [Hive](https://en.wikipedia.org/wiki/Hive_(game))
* [magic bitboard perft](http://www.talkchess.com/forum3/viewtopic.php?f=7&t=73625) by [Richard Delorme](Richard_Delorme "Richard Delorme"), [CCC](CCC "CCC"), April 11, 2020 » [Perft](Perft "Perft")
* [What is the point of magic hashing over simply using masked occupancy as index ?](http://www.talkchess.com/forum3/viewtopic.php?f=7&t=77648) by Gautier Blandin, [CCC](CCC "CCC"), July 06, 2021 » [Hashing Dictionaries](Hashing_Dictionaries "Hashing Dictionaries")


## External Links


* [Buzz - A Winboard Chess Playing Program by Pradu Kannan](http://www.pradu.us/old/Nov27_2008/Buzz/) - Source of [Pradu Kannan's](Pradu_Kannan "Pradu Kannan") magic Move Generator
* [Rival Chess Engine - Magic Bitboards](http://web.archive.org/web/20160304114223/http://www.rivalchess.com/magic-bitboards/) ([Wayback Machine](https://en.wikipedia.org/wiki/Wayback_Machine)) by [Russell Newman](Russell_Newman "Russell Newman") and [Chris Moreton](Chris_Moreton "Chris Moreton") » [Rival](Rival "Rival")
* [Understanding magic bitboards in chess programming](http://web.archive.org/web/20160314001240/http://www.afewmorelines.com/understanding-magic-bitboards-in-chess-programming/) ([Wayback Machine](https://en.wikipedia.org/wiki/Wayback_Machine)) by [Chris Moreton](Chris_Moreton "Chris Moreton") in his programming blog, August 07, 2013
* [Chess Programming | Generating Magic Multipliers](http://www.chessprogramming.net/generating-magic-multipliers/) by [Steve Maughan](Steve_Maughan "Steve Maughan") » [Looking for Magics](Looking_for_Magics "Looking for Magics")
* [chess - Sliding move generation using magic bitboard](http://stackoverflow.com/questions/16925204/sliding-move-generation-using-magic-bitboard) - [Stack Overflow](https://en.wikipedia.org/wiki/Stack_Overflow), June 4, 2013
* [M42](https://sites.google.com/site/sydfhd/projects/m42) by [Syed Fahad](Syed_Fahad "Syed Fahad") <a id="cite-note-27" href="#cite-ref-27">[27]</a>
* [GitHub - goutham/magic-bits: Magic-bitboards for Chess](https://github.com/goutham/magic-bits) by [Goutham Bhat](index.php?title=Goutham_Bhat&action=edit&redlink=1 "Goutham Bhat (page does not exist)")
* [Fast Chess Move Generation With Magic Bitboards](https://rhysre.net/fast-chess-move-generation-with-magic-bitboards.html) by [Rhys Rustad-Elliott](Rhys_Rustad-Elliott "Rhys Rustad-Elliott"), January 15, 2019


## Other Magic Stuff


* [Magic from Wikipedia](https://en.wikipedia.org/wiki/Magic)
* [Magic (illusion) from Wikipedia](https://en.wikipedia.org/wiki/Magic_%28illusion%29)
* [Magic (paranormal) from Wikipedia](https://en.wikipedia.org/wiki/Magic_%28paranormal%29)
* [Magic (cryptography) from Wikipedia](https://en.wikipedia.org/wiki/Magic_%28cryptography%29)
* [Magic number from Wikipedia](https://en.wikipedia.org/wiki/Magic_number_%28programming%29)
* [Magic constant from Wikipedia](https://en.wikipedia.org/wiki/Magic_constant)
* [Magic square from Wikipedia](https://en.wikipedia.org/wiki/Magic_square)
* [Magic hypercube from Wikipedia](https://en.wikipedia.org/wiki/Magic_hypercube)
* Five Senses - Magic Constant, [Christmas Jazz Festival](http://www.kalevatravel.ee/index.aw/tallinn2011_culture_capital_europe), [Tallinn](https://en.wikipedia.org/wiki/Tallinn), December 10, 2011, [YouTube](https://en.wikipedia.org/wiki/YouTube) Video


 line-up: [Nguyên Lê](Category:Nguy%C3%AAn_L%C3%AA "Category:Nguyên Lê"), [Claudio Puntin](https://de.wikipedia.org/wiki/Claudio_Puntin), [Steffen Schorn](https://de.wikipedia.org/wiki/Steffen_Schorn), [Kristjan Randalu](https://de.wikipedia.org/wiki/Kristjan_Randalu), [Bodek Janke](http://www.bodekjanke.de/english/home.php)
 
* [Youn Sun Nah](Category:Youn_Sun_Nah "Category:Youn Sun Nah") - [Momento Magico](http://www.allaboutjazz.com/lento-youn-sun-nah-act-music-review-by-ian-patterson.php) (2013), [YouTube](https://en.wikipedia.org/wiki/YouTube) Video


 [Youn Sun Nah](Category:Youn_Sun_Nah "Category:Youn Sun Nah"), [Ulf Wakenius](Category:Ulf_Wakenius "Category:Ulf Wakenius"), [Lars Danielsson](Category:Lars_Danielsson "Category:Lars Danielsson"), [Vincent Peirani](Category:Vincent_Peirani "Category:Vincent Peirani")
 
## References


1. <a id="cite-ref-1" href="#cite-note-1">↑</a> [Paul Klee - Magic Garden, 1926](https://commons.wikimedia.org/wiki/File:GUGG_Magic_Garden.jpg), [Solomon R. Guggenheim Museum](https://en.wikipedia.org/wiki/Solomon_R._Guggenheim_Museum)
2. <a id="cite-ref-2" href="#cite-note-2">↑</a> [Re: BitBoard Tests Magic v Non-Rotated 32 Bits v 64 Bits](http://www.talkchess.com/forum/viewtopic.php?topic_view=threads&p=140141&t=16002) by [Robert Hyatt](Robert_Hyatt "Robert Hyatt"), [CCC](CCC "CCC"), August 25, 2007
3. <a id="cite-ref-3" href="#cite-note-3">↑</a> [Arasan Blog - Aug 26, 2008](http://www.arasanchess.org/blogs/aug08.html) by [Jon Dart](Jon_Dart "Jon Dart")
4. <a id="cite-ref-4" href="#cite-note-4">↑</a> [rotated bitboards obsolete?](https://www.stmintz.com/ccc/index.php?id=489834) by [Gerd Isenberg](Gerd_Isenberg "Gerd Isenberg"), [CCC](CCC "CCC"), February 26, 2006
5. <a id="cite-ref-5" href="#cite-note-5">↑</a> [Fast(er) bitboard move generator](http://www.open-aurec.com/wbforum/viewtopic.php?t=5015) by [Lasse Hansen](Lasse_Hansen "Lasse Hansen"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), June 14, [2006](Timeline#2006 "Timeline"), Initial idea
6. <a id="cite-ref-6" href="#cite-note-6">↑</a> [Pradu Kannan](Pradu_Kannan "Pradu Kannan") (**2007**). *Magic Move-Bitboard Generation in Computer Chess*, as [pdf](http://www.pradu.us/old/Nov27_2008/Buzz/research/magic/Bitboards.pdf)
7. <a id="cite-ref-7" href="#cite-note-7">↑</a> [List of magics for bitboard move generation](http://www.open-aurec.com/wbforum/viewtopic.php?t=5441) by [Pradu Kannan](Pradu_Kannan "Pradu Kannan"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), August 23, [2006](Timeline#2006 "Timeline")
8. <a id="cite-ref-8" href="#cite-note-8">↑</a> [Plain and fancy magic on modern hardware](http://www.talkchess.com/forum/viewtopic.php?t=35858) by [Robert Purves](index.php?title=Robert_Purves&action=edit&redlink=1 "Robert Purves (page does not exist)"), [CCC](CCC "CCC"), August 22, 2010
9. <a id="cite-ref-9" href="#cite-note-9">↑</a> [Buzz - A Winboard Chess Playing Program by Pradu Kannan](http://www.pradu.us/old/Nov27_2008/Buzz/) - Source of [Pradu Kannan's](Pradu_Kannan "Pradu Kannan") magic Move Generator, PERFECT\_MAGIC\_HASH
10. <a id="cite-ref-10" href="#cite-note-10">↑</a> [Buzz - A Winboard Chess Playing Program by Pradu Kannan](http://www.pradu.us/old/Nov27_2008/Buzz/) - Source of [Pradu Kannan's](Pradu_Kannan "Pradu Kannan") magic Move Generator, MINIMIZE\_MAGIC
11. <a id="cite-ref-11" href="#cite-note-11">↑</a> [Magic with fixed shift](http://www.open-aurec.com/wbforum/viewtopic.php?f=4&t=50043) by [Onno Garms](Onno_Garms "Onno Garms"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), March 18, 2009
12. <a id="cite-ref-12" href="#cite-note-12">↑</a> [Fixed shift magics with 800KB lookup table](http://www.open-aurec.com/wbforum/viewtopic.php?f=4&t=51162) by [Volker Annuss](Volker_Annuss "Volker Annuss"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), September, 05, 2010
13. <a id="cite-ref-13" href="#cite-note-13">↑</a> [Re: understanding fixed shift fancy magic bitboard generation](http://www.talkchess.com/forum/viewtopic.php?t=60065&start=14) by [Volker Annuss](Volker_Annuss "Volker Annuss"), [CCC](CCC "CCC"), May 06, 2016
14. <a id="cite-ref-14" href="#cite-note-14">↑</a> [Black magic bitboards](http://www.talkchess.com/forum/viewtopic.php?t=64790) by [Volker Annuss](Volker_Annuss "Volker Annuss"), [CCC](CCC "CCC"), August 03, 2017
15. <a id="cite-ref-15" href="#cite-note-15">↑</a> [Re: Black magic bitboards](http://www.talkchess.com/forum/viewtopic.php?t=64790&start=11) by [Volker Annuss](Volker_Annuss "Volker Annuss"), [CCC](CCC "CCC"), August 04, 2017
16. <a id="cite-ref-16" href="#cite-note-16">↑</a> [Re: Black magic bitboards](http://www.talkchess.com/forum/viewtopic.php?t=64790&start=14) by [Volker Annuss](Volker_Annuss "Volker Annuss"), [CCC](CCC "CCC"), August 04, 2017
17. <a id="cite-ref-17" href="#cite-note-17">↑</a> source code according to the [fixed shift fancy](#FixedShiftFancy) sample - array size from Volker's posting, also containing black magics and arrayoffsets, see [Black magic bitboards](http://www.talkchess.com/forum/viewtopic.php?t=64790) by [Volker Annuss](Volker_Annuss "Volker Annuss"), [CCC](CCC "CCC"), August 03, 2017
18. <a id="cite-ref-18" href="#cite-note-18">↑</a> [Re: Plain and fancy magic on modern hardware](http://www.talkchess.com/forum/viewtopic.php?topic_view=threads&p=368026&t=35858) by [Robert Houdart](Robert_Houdart "Robert Houdart"), [CCC](CCC "CCC"), August 26, 2010
19. <a id="cite-ref-19" href="#cite-note-19">↑</a> [A Faster Magic Move Bitboard Generator?](http://www.open-aurec.com/wbforum/viewtopic.php?t=5997) by [Grant Osborne](Grant_Osborne "Grant Osborne"), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), December 15, 2006
20. <a id="cite-ref-20" href="#cite-note-20">↑</a> [Lasse Hansen's](Lasse_Hansen "Lasse Hansen") [postmask trick](http://www.open-aurec.com/wbforum/viewtopic.php?topic_view=threads&p=185506&t=5441), [Winboard Forum](Computer_Chess_Forums "Computer Chess Forums"), May 09, 2008
21. <a id="cite-ref-21" href="#cite-note-21">↑</a> [Incorporating the shift into the magic number](http://www.talkchess.com/forum/viewtopic.php?topic_view=threads&p=196157&t=21329) by [Grant Osborne](Grant_Osborne "Grant Osborne"), [CCC](CCC "CCC"), June 18, 2008
22. <a id="cite-ref-22" href="#cite-note-22">↑</a> [magic number comprising offset](http://www.talkchess.com/forum/viewtopic.php?t=66538) by [Eugene Kotlov](index.php?title=Eugene_Kotlov&action=edit&redlink=1 "Eugene Kotlov (page does not exist)"), [CCC](CCC "CCC"), February 07, 2018
23. <a id="cite-ref-23" href="#cite-note-23">↑</a> [Shift and Address included into Magic number](http://www.talkchess.com/forum3/viewtopic.php?f=7&t=69947) by [Eugene Kotlov](index.php?title=Eugene_Kotlov&action=edit&redlink=1 "Eugene Kotlov (page does not exist)"), [CCC](CCC "CCC"), February 18, 2019
24. <a id="cite-ref-24" href="#cite-note-24">↑</a> [Movegen Re: Bitmap Type Re: Tinker 81 secs Re: Testing speed](https://www.stmintz.com/ccc/index.php?id=107485) by [Brian Richardson](Brian_Richardson "Brian Richardson"), [CCC](CCC "CCC"), April 24, 2000
25. <a id="cite-ref-25" href="#cite-note-25">↑</a> [M42](https://sites.google.com/site/sydfhd/projects/m42) by [Syed Fahad](Syed_Fahad "Syed Fahad")
26. <a id="cite-ref-26" href="#cite-note-26">↑</a> [Strong NP-completeness from Wikipedia](https://en.wikipedia.org/wiki/Strong_NP-completeness)
27. <a id="cite-ref-27" href="#cite-note-27">↑</a> [M42 - A C++ library for Bitboard attack mask generation](http://www.talkchess.com/forum/viewtopic.php?t=60007) by [Syed Fahad](Syed_Fahad "Syed Fahad"), [CCC](CCC "CCC"), April 30, 2016

**[Up one Level](Sliding_Piece_Attacks "Sliding Piece Attacks")**







 
